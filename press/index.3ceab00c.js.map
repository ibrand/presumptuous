{"mappings":"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","sources":["<anon>","press/press.js","node_modules/proseplay/dist/proseplay-module.js","node_modules/proseplay/dist/src/proseplay.ts","node_modules/proseplay/dist/src/window.ts","node_modules/proseplay/dist/src/choice.ts"],"sourcesContent":["\nconst $9b061c90e4c8fb40$var$$97aedba7ab332eed$var$windowTemplate = document.createElement(\"div\");\n$9b061c90e4c8fb40$var$$97aedba7ab332eed$var$windowTemplate.classList.add(\"proseplay-window\");\nconst $9b061c90e4c8fb40$var$$97aedba7ab332eed$var$listTemplate = document.createElement(\"div\");\n$9b061c90e4c8fb40$var$$97aedba7ab332eed$var$listTemplate.classList.add(\"proseplay-list\");\n$9b061c90e4c8fb40$var$$97aedba7ab332eed$var$windowTemplate.append($9b061c90e4c8fb40$var$$97aedba7ab332eed$var$listTemplate);\nconst $9b061c90e4c8fb40$var$$97aedba7ab332eed$var$linkRefTemplate = document.createElement(\"sup\");\n$9b061c90e4c8fb40$var$$97aedba7ab332eed$var$linkRefTemplate.classList.add(\"proseplay-link-ref\");\nconst $9b061c90e4c8fb40$var$$97aedba7ab332eed$var$BUFFER_TIME = 15;\nlet $9b061c90e4c8fb40$var$$97aedba7ab332eed$var$PADDING;\nconst $9b061c90e4c8fb40$var$$97aedba7ab332eed$var$mouse = {\n    x: 0,\n    y: 0\n};\nclass $9b061c90e4c8fb40$var$$97aedba7ab332eed$export$cec157cbbbaf65c9 {\n    links = [];\n    horizontal = false;\n    constructor(parent){\n        this.el = $9b061c90e4c8fb40$var$$97aedba7ab332eed$var$windowTemplate.cloneNode(true);\n        parent.appendChild(this.el);\n        this.el.addEventListener(\"pointerover\", this.handlePointerOver);\n        this.el.addEventListener(\"pointerdown\", this.handlePointerDown);\n        this.el.addEventListener(\"pointermove\", this.handlePointerMove);\n        this.el.addEventListener(\"pointerup\", this.handlePointerUp);\n        this.el.addEventListener(\"pointerout\", this.handlePointerOut);\n        this.listEl = this.el.querySelector(\".proseplay-list\");\n        this.choices = [];\n        this.currentIndex = 0;\n        this.isHoverable = true;\n        this.isDragged = false;\n        this.linkIndex = null;\n        this.functionNames = [];\n        this.functions = {};\n        $9b061c90e4c8fb40$var$$97aedba7ab332eed$var$PADDING = parseInt(getComputedStyle(parent).fontSize) * 0.3;\n    }\n    /**\n   * Change the direction of the window to horizontal, i.e. east–west.\n   */ setHorizontal() {\n        this.horizontal = true;\n        this.el.classList.add(\"proseplay-horizontal\");\n    }\n    /**\n   * Add a choice to the window.\n   * @param choice The choice object to be added.\n   */ addChoice(choice) {\n        this.choices.push(choice);\n        this.listEl.appendChild(choice.el);\n    }\n    /**\n   * Activate the specified choice and adjusts position and sizing accordingly.\n   * @param choice The choice to be activated. If none is given, it readjusts to the current choice — this can be useful for resizing.\n   */ activateChoice(choice) {\n        if (!choice) {\n            choice = this.choices[this.currentIndex];\n            if (!this.horizontal) this.listEl.style.top = `-${choice.offsetTop}px`;\n            else this.listEl.style.left = `${-Math.abs(choice.offsetLeft) + $9b061c90e4c8fb40$var$$97aedba7ab332eed$var$PADDING}px`;\n        }\n        this.currentIndex = this.choices.indexOf(choice);\n        this.choices.forEach((otherChoice)=>otherChoice.deactivate());\n        choice.activate();\n        this.el.style.width = `${choice.offsetWidth}px`;\n    }\n    /**\n   * Get a random choice index.\n   * @returns The random chocie index.\n   */ random() {\n        return Math.floor(Math.random() * this.choices.length);\n    }\n    slideToPos(pos) {\n        if (!this.horizontal) this.listEl.style.top = `${pos}px`;\n        else this.listEl.style.left = `${pos}px`;\n        const targetChoice = this.getNearestChoice(pos);\n        if (!targetChoice) return;\n        this.activateChoice(targetChoice);\n    }\n    /**\n   * Slide to a specified index in the window's array of choices.\n   * @param choiceIndex Index of choice to slide to.\n   */ slideToChoice(choiceIndex, duration) {\n        if (choiceIndex > this.choices.length - 1) return;\n        const choice = this.choices[choiceIndex];\n        this.pointerOver();\n        this.pointerDown();\n        this.listEl.classList.add(\"proseplay-has-transition\");\n        this.listEl.addEventListener(\"transitionend\", (e)=>{\n            if (e.target !== this.listEl) return;\n            this.listEl.classList.remove(\"proseplay-has-transition\");\n        });\n        if (duration) {\n            this.listEl.style.transitionDuration = `${duration}ms`;\n            this.listEl.addEventListener(\"transitionend\", ()=>{\n                this.listEl.style.removeProperty(\"transition-duration\");\n            });\n            this.choices.forEach((choice)=>{\n                choice.el.style.transitionDuration = `${duration}ms`;\n                choice.el.addEventListener(\"transitionend\", ()=>{\n                    choice.el.style.removeProperty(\"transition-duration\");\n                });\n            });\n            this.el.style.transitionDuration = `${duration}ms`;\n            this.el.addEventListener(\"transitionend\", ()=>{\n                this.el.style.removeProperty(\"transition-duration\");\n            });\n        }\n        setTimeout(()=>{\n            if (!this.horizontal) this.listEl.style.top = `-${choice.offsetTop}px`;\n            else this.listEl.style.left = `${-Math.abs(choice.offsetLeft) + $9b061c90e4c8fb40$var$$97aedba7ab332eed$var$PADDING}px`;\n        }, $9b061c90e4c8fb40$var$$97aedba7ab332eed$var$BUFFER_TIME);\n        this.pointerUp();\n        this.pointerOut();\n        this.activateChoice(choice);\n    }\n    getNearestChoice(pos) {\n        let minDist = Infinity;\n        let targetChoice = null;\n        this.choices.forEach((choice)=>{\n            let dist = !this.horizontal ? Math.abs(pos + choice.offsetTop) : Math.abs(pos + choice.offsetLeft - $9b061c90e4c8fb40$var$$97aedba7ab332eed$var$PADDING);\n            if (dist < minDist) {\n                minDist = dist;\n                targetChoice = choice;\n            }\n        });\n        return targetChoice;\n    }\n    snapToNearestChoice() {\n        const choice = this.getNearestChoice(this.pos);\n        if (!choice) return;\n        if (!this.horizontal) this.listEl.style.top = `-${choice.offsetTop}px`;\n        else this.listEl.style.left = `${-Math.abs(choice.offsetLeft) + $9b061c90e4c8fb40$var$$97aedba7ab332eed$var$PADDING}px`;\n    }\n    /**\n   * Return either the `left` or `top` of the window's list element, depending on the direction of the window.\n   */ get pos() {\n        const property = this.horizontal ? \"left\" : \"top\";\n        return parseInt(getComputedStyle(this.listEl).getPropertyValue(property).replace(\"px\", \"\"));\n    }\n    handlePointerOver = (e)=>{\n        e.preventDefault();\n        if (!this.isHoverable) return;\n        const target = e.target;\n        if (!target.classList.contains(\"proseplay-current\")) return;\n        this.el.closest(\".proseplay\").querySelectorAll(\".proseplay-line\").forEach((line)=>{\n            line.classList.add(\"proseplay-has-hover\");\n        });\n        this.pointerOver();\n    };\n    pointerOver() {\n        this.el.classList.add(\"proseplay-hover\");\n    }\n    handlePointerDown = (e)=>{\n        e.preventDefault();\n        if (!this.isHoverable) return;\n        const target = e.target;\n        if (!target.classList.contains(\"proseplay-current\")) return;\n        this.el.setPointerCapture(e.pointerId);\n        this.links.forEach((window1)=>window1.pointerDown());\n        this.isDragged = true;\n        $9b061c90e4c8fb40$var$$97aedba7ab332eed$var$mouse.x = e.clientX;\n        $9b061c90e4c8fb40$var$$97aedba7ab332eed$var$mouse.y = e.clientY;\n    };\n    pointerDown() {\n        this.el.classList.add(\"proseplay-hover\");\n    }\n    handlePointerMove = (e)=>{\n        e.preventDefault();\n        if (!this.isDragged) return;\n        const dist = !this.horizontal ? $9b061c90e4c8fb40$var$$97aedba7ab332eed$var$mouse.y - e.clientY : $9b061c90e4c8fb40$var$$97aedba7ab332eed$var$mouse.x - e.clientX;\n        this.slideToPos(this.pos - dist);\n        this.links.forEach((window1)=>{\n            window1.slideToPos(this.pos - dist);\n        });\n        $9b061c90e4c8fb40$var$$97aedba7ab332eed$var$mouse.x = e.clientX;\n        $9b061c90e4c8fb40$var$$97aedba7ab332eed$var$mouse.y = e.clientY;\n    };\n    handlePointerOut = ()=>{\n        if (this.isDragged) return;\n        this.el.closest(\".proseplay\").querySelectorAll(\".proseplay-line\").forEach((line)=>{\n            line.classList.remove(\"proseplay-has-hover\");\n        });\n        this.pointerOut();\n        this.links.forEach((window1)=>window1.pointerOut());\n    };\n    pointerOut() {\n        this.isDragged = false;\n        this.el.classList.remove(\"proseplay-hover\");\n    }\n    handlePointerUp = (e)=>{\n        e.preventDefault();\n        this.pointerUp();\n        this.links.forEach((window1)=>window1.pointerUp());\n    };\n    pointerUp() {\n        this.snapToNearestChoice();\n        this.isDragged = false;\n        this.el.classList.remove(\"proseplay-hover\");\n        let functionName = this.functionNames[this.currentIndex];\n        if (functionName) {\n            if (this.functions[functionName]) this.functions[functionName]();\n        }\n        this.el.closest(\".proseplay\").querySelectorAll(\".proseplay-line\").forEach((line)=>{\n            line.classList.remove(\"proseplay-has-hover\");\n        });\n    }\n    /**\n   * Set link between this window and other windows.\n   * @param linkIndex Index number of link, as indicated in square brackets.\n   * @param otherWindows Array of other windows in the same link.\n   */ setLink(linkIndex, otherWindows) {\n        this.linkIndex = linkIndex;\n        if (linkIndex) {\n            const sup = $9b061c90e4c8fb40$var$$97aedba7ab332eed$var$linkRefTemplate.cloneNode(true);\n            this.el.insertAdjacentElement(\"afterend\", sup);\n            sup.innerText = `${linkIndex}`;\n        }\n        this.links = otherWindows;\n    }\n    /**\n   * Set function names.\n   * @param functionNames Array of function names.\n   */ setFunctionNames(functionNames) {\n        this.functionNames = functionNames;\n    }\n    /**\n   * Assign functions to function names.\n   * @param name Name of function.\n   * @param fnc Function to be called.\n   */ setFunction(name, fnc) {\n        this.functions[name] = fnc;\n    }\n}\nconst $9b061c90e4c8fb40$var$$fb2114d596aef9c8$var$choiceTemplate = document.createElement(\"div\");\n$9b061c90e4c8fb40$var$$fb2114d596aef9c8$var$choiceTemplate.classList.add(\"proseplay-choice\");\nclass $9b061c90e4c8fb40$var$$fb2114d596aef9c8$export$32a7462f6a06cbd5 {\n    text = \"\";\n    isCurrent = false;\n    constructor(text){\n        this.text = text;\n        this.el = $9b061c90e4c8fb40$var$$fb2114d596aef9c8$var$choiceTemplate.cloneNode(true);\n        if (text !== \" \") this.el.innerText = text;\n        else this.el.innerHTML = \"&thinsp;\";\n    }\n    /**\n   * Activate this choice.\n   */ activate() {\n        this.isCurrent = true;\n        this.el.classList.add(\"proseplay-current\");\n    }\n    /**\n   * Deactivate this choice.\n   */ deactivate() {\n        this.isCurrent = false;\n        this.el.classList.remove(\"proseplay-current\");\n    }\n    /**\n   * Get the `offsetTop` of this element.\n   */ get offsetTop() {\n        return this.el.offsetTop;\n    }\n    /**\n   * Get the `offsetLeft` of this element.\n   */ get offsetLeft() {\n        return this.el.offsetLeft;\n    }\n    /**\n   * Get the `offsetWidth` of this element.\n   */ get offsetWidth() {\n        return this.el.offsetWidth;\n    }\n}\nconst $9b061c90e4c8fb40$var$$79098f0a1478fa01$var$lineTemplate = document.createElement(\"div\");\n$9b061c90e4c8fb40$var$$79098f0a1478fa01$var$lineTemplate.classList.add(\"proseplay-line\");\nconst $9b061c90e4c8fb40$var$$79098f0a1478fa01$var$samples = {\n    dickinson: `We talked with each other about each other\nThough neither of us spoke \\u{2014}\nWe were (too engrossed with|listening to) the Second\\u{2019}s Races\nAnd the Hoofs of the Clock \\u{2014}\nPausing in Front of our (Sentenced Faces|Foundering Faces)\n(Time\\u{2019}s Decision shook \\u{2014}|Time compassion Took)\nArks of Reprieve he offered to us \\u{2014}\nArarats \\u{2014} we took \\u{2014}`,\n    homophones: `in the (mist|missed) (see|sea)\n(prey|pray) in the (morning|mourning)\nfor (words|worlds) that (exit|exist)\nas (seep|sleep)`,\n    hypothetically: `(hypothetically|hello)[1-]\n(what if|i said)[1-]\n(we fell|and held)[1-]\n(in love|till death)[1-]`\n};\nlet $9b061c90e4c8fb40$var$$79098f0a1478fa01$var$EM;\nclass $9b061c90e4c8fb40$export$bb601a587602e2b4 {\n    lines = [];\n    windows = [];\n    links = [];\n    _isExpanded = false;\n    functions = {};\n    /**\n   * Create a new ProsePlay object, which will be contained in the given HTML element.\n   * @param el The HTML element in which the ProsePlay instance will be contained.\n   */ constructor(el){\n        this.el = el;\n        this.el.classList.add(\"proseplay\");\n        window.addEventListener(\"resize\", this.handleResize);\n        document.addEventListener(\"DOMContentLoaded\", this.handleResize);\n        $9b061c90e4c8fb40$var$$79098f0a1478fa01$var$EM = parseInt(getComputedStyle(el).fontSize);\n    }\n    static createInstance() {\n        const container = document.createElement(\"div\");\n        container.classList.add(\"proseplay\");\n        document.body.appendChild(container);\n        const pp = new $9b061c90e4c8fb40$export$bb601a587602e2b4(container);\n        return pp;\n    }\n    /**\n   * Load a sample.\n   * @param name The name of the sample to load.\n   * @returns The ProsePlay instance with the parsed text.\n   */ load(name) {\n        this.lines = [];\n        this.windows = [];\n        this.links = [];\n        return this.parse($9b061c90e4c8fb40$var$$79098f0a1478fa01$var$samples[name]);\n    }\n    /**\n   * Create a ProsePlay instance and load a sample.\n   * @param name The name of the sample to load.\n   * @returns A ProsePlay instance with the parsed text.\n   */ static load(name) {\n        const pp = $9b061c90e4c8fb40$export$bb601a587602e2b4.createInstance();\n        return pp.load(name);\n    }\n    /**\n   * Parse the given string.\n   * @param str The formatted string to parse.\n   * @returns The ProsePlay instance with the parsed text.\n   */ parse(str) {\n        this.lines = [];\n        this.windows = [];\n        this.links = [];\n        str = str.trim();\n        let textTokens = [];\n        let lines = str.split(\"\\n\");\n        lines.forEach((line)=>{\n            const lineTokens = [];\n            let m = line.matchAll(new RegExp(\"\\\\(([^(|)]+\\\\|([^(|)]+\\\\|?)+)\\\\)(\\\\[(\\\\d)*(-)?\\\\])?\" // link index\n            , \"g\"));\n            const stringsIndex = 1, linkIndex = 4, orientationIndex = 5;\n            let currIndex = 0;\n            for (const match of m){\n                const index = match.index;\n                let isEscaped = line[index - 2] === \"\\\\\";\n                let prevToken = {\n                    strings: []\n                }, currentToken = {\n                    strings: []\n                };\n                if (isEscaped) {\n                    prevToken.strings = [\n                        line.slice(currIndex, index - 1)\n                    ];\n                    currentToken.strings = [\n                        line.slice(index, index + match[0].length)\n                    ];\n                } else {\n                    prevToken.strings = [\n                        line.slice(currIndex, index)\n                    ];\n                    currentToken.strings = match[stringsIndex].split(\"|\");\n                    currentToken.strings.forEach((str, i)=>{\n                        let [s, fnc] = str.split(\"->\");\n                        if (fnc) {\n                            if (!currentToken.functionNames) currentToken.functionNames = [];\n                            currentToken.functionNames[i] = fnc;\n                            currentToken.strings[i] = s;\n                        }\n                    });\n                    if (match[linkIndex]) currentToken.linkIndex = parseInt(match[linkIndex]);\n                    if (match[orientationIndex] && (match[orientationIndex] === \"|\" || match[orientationIndex] === \"-\")) currentToken.horizontal = match[orientationIndex] === \"-\";\n                }\n                lineTokens.push(prevToken);\n                lineTokens.push(currentToken);\n                currIndex = index + match[0].length;\n            }\n            if (currIndex < line.length) lineTokens.push({\n                strings: [\n                    line.slice(currIndex)\n                ]\n            });\n            textTokens.push(lineTokens);\n        });\n        this.constructText(textTokens);\n        return this;\n    }\n    /**\n   * Create a new ProsePlay instance and parse the given string.\n   * @param str The formatted string to parse.\n   * @returns A ProsePlay instance with the parsed text.\n   */ static parse(str) {\n        const pp = $9b061c90e4c8fb40$export$bb601a587602e2b4.createInstance();\n        pp.parse(str);\n        return pp;\n    }\n    constructText(text) {\n        this.el.innerHTML = \"\";\n        text.forEach((line)=>{\n            const lineEl = $9b061c90e4c8fb40$var$$79098f0a1478fa01$var$lineTemplate.cloneNode(true);\n            this.el.appendChild(lineEl);\n            this.lines.push({\n                el: lineEl,\n                tokens: [],\n                windows: []\n            });\n            line.forEach((token)=>{\n                if (token.strings.length === 1) {\n                    const span = document.createElement(\"span\");\n                    span.classList.add(\"proseplay-plaintext\");\n                    span.innerText = token.strings[0];\n                    lineEl.append(span);\n                    this.lines[this.lines.length - 1].tokens.push(token.strings[0]);\n                } else {\n                    const window1 = new $9b061c90e4c8fb40$var$$97aedba7ab332eed$export$cec157cbbbaf65c9(lineEl);\n                    if (token.linkIndex) {\n                        if (!this.links[token.linkIndex]) this.links[token.linkIndex] = [];\n                        this.links[token.linkIndex].push(window1);\n                    }\n                    if (token.functionNames) window1.setFunctionNames(token.functionNames);\n                    for(const name in this.functions)window1.setFunction(name, this.functions[name]);\n                    if (token.horizontal) window1.setHorizontal();\n                    this.lines[this.lines.length - 1].tokens.push(window1);\n                    this.lines[this.lines.length - 1].windows.push(window1);\n                    this.windows.push(window1);\n                    token.strings.forEach((str)=>window1.addChoice(new $9b061c90e4c8fb40$var$$fb2114d596aef9c8$export$32a7462f6a06cbd5(str)));\n                    window1.activateChoice(window1.choices[0]);\n                }\n            });\n            if (line.length === 0) lineEl.innerHTML = \"&nbsp;\";\n        });\n        this.links.forEach((windows, i)=>{\n            windows.forEach((window1)=>{\n                const otherWindows = windows.filter((otherWindow)=>otherWindow !== window1);\n                window1.setLink(i, otherWindows);\n            });\n        });\n    }\n    /**\n   * Slide each window to a random choice. If windows are linked, they will move to the same choice index together. If no `windowIndexes` is specified, all windows will be randomised.\n   */ randomise(options) {\n        if (this._isExpanded) return;\n        const windowIndexes = options?.windowIndexes || this.windows.map((_, i)=>i);\n        let windowsDragged = [];\n        windowIndexes.forEach((i)=>{\n            const window1 = this.windows[i];\n            if (!window1) return;\n            if (windowsDragged.includes(window1)) return;\n            let choiceIndex = window1.random();\n            window1.slideToChoice(choiceIndex, options?.millis);\n            windowsDragged.push(window1);\n            if (window1.linkIndex) this.links[window1.linkIndex].forEach((otherWindow)=>{\n                if (windowsDragged.includes(otherWindow)) return;\n                otherWindow.slideToChoice(choiceIndex, options?.millis);\n                windowsDragged.push(otherWindow);\n            });\n        });\n    }\n    /**\n   * Alias for `randomise()`.\n   * @param windowIndexes An optional list of window indexes to randomise.\n   */ randomize(options) {\n        this.randomise(options);\n    }\n    /**\n   * Expand all windows to show all choices at once. When this is enabled, all other interactions are disabled until `collapse()` is called.\n   */ expand() {\n        this._isExpanded = true;\n        this.el.classList.toggle(\"proseplay-is-expanded\", this._isExpanded);\n        const em = parseFloat(getComputedStyle(this.el).fontSize);\n        this.lines.forEach((line)=>{\n            let marginBottom = 0;\n            line.windows.forEach((window1)=>{\n                let height = window1.el.scrollHeight - window1.listEl.offsetTop;\n                window1.el.style.height = `${height}px`;\n                let y = window1.el.scrollHeight - (window1.currentIndex + 1) * 1.25 * em - 0.06 * em;\n                window1.el.style.top = `${y}px`;\n                window1.el.style.marginTop = `${-y}px`;\n                marginBottom = Math.max(marginBottom, y);\n                window1.listEl.style.top = \"0px\";\n                let maxWidth = 0;\n                window1.choices.forEach((choice, i)=>{\n                    choice.el.style.opacity = \"1\";\n                    if (!window1.horizontal) maxWidth = Math.max(maxWidth, choice.el.offsetWidth);\n                    else {\n                        if (i > 0) maxWidth += $9b061c90e4c8fb40$var$$79098f0a1478fa01$var$EM;\n                        maxWidth += choice.el.offsetWidth;\n                    }\n                });\n                window1.el.style.width = `${maxWidth}px`;\n                window1.isHoverable = false;\n            });\n            line.el.style.marginBottom = `${marginBottom}px`;\n        });\n    }\n    /**\n   * Collapse all windows.\n   */ collapse() {\n        this._isExpanded = false;\n        this.el.classList.toggle(\"proseplay-is-expanded\", this._isExpanded);\n        this.lines.forEach((line)=>{\n            line.el.style.removeProperty(\"margin-bottom\");\n            line.windows.forEach((window1)=>{\n                window1.el.style.removeProperty(\"height\");\n                window1.el.style.removeProperty(\"top\");\n                window1.el.style.removeProperty(\"margin-top\");\n                window1.listEl.style.removeProperty(\"top\");\n                window1.choices.forEach((choice)=>{\n                    choice.el.style.removeProperty(\"opacity\");\n                });\n                window1.listEl.style.removeProperty(\"width\");\n                window1.isHoverable = true;\n                window1.activateChoice();\n            });\n        });\n    }\n    /**\n   * Check if windows are expanded or collapsed.\n   * @returns A boolean representing whether windows are expanded (true) or collapsed (false).\n   */ get isExpanded() {\n        return this._isExpanded;\n    }\n    /**\n   * Return the current text.\n   * @returns A string of the current text.\n   */ snapshot() {\n        let text = \"\";\n        this.lines.forEach((line)=>{\n            line.tokens.forEach((token)=>{\n                if (token instanceof $9b061c90e4c8fb40$var$$97aedba7ab332eed$export$cec157cbbbaf65c9) text += token.choices[token.currentIndex].text;\n                else text += token;\n            });\n            text += \"\\n\";\n        });\n        return text;\n    }\n    /**\n   * Set function to be called when certain choices are selected.\n   * @param name Name of function.\n   * @param fnc Function to be called.\n   */ setFunction(name, fnc) {\n        this.functions[name] = fnc;\n        this.windows.forEach((window1)=>window1.setFunction(name, fnc));\n    }\n    handleResize = ()=>{\n        this.windows.forEach((window1)=>window1.activateChoice());\n    };\n    /**\n   * Return a nested list of choices in each window.\n   */ get choices() {\n        return this.windows.map((window1)=>{\n            return window1.choices.map((choice)=>choice.text);\n        });\n    }\n    /**\n   * Return a list of indexes to which each window is currently set.\n   */ get currentIndexes() {\n        return this.windows.map((window1)=>window1.currentIndex);\n    }\n    /**\n   * Slide a specified window to a specified choice.\n   * @param windowIndex The index of the window to slide.\n   * @param choiceIndex The index of the choice to slide to.\n   */ slideWindow(windowIndex, choiceIndex, options) {\n        if (windowIndex > this.windows.length - 1) return;\n        const window1 = this.windows[windowIndex];\n        if (choiceIndex > window1.choices.length - 1) return;\n        window1.slideToChoice(choiceIndex, options?.millis);\n    }\n}\n\n\nconst $98d79d017ae06d24$var$poem = `Press(ure|ing juice| |ume->removeEase)[1]\n\n\n(Absently|Anxiously| |Patiently->removeEase)[1] waiting for (cracks to show through|you to come through.| |me to come to->removeEase)[1]\n\n(Pressure creates the environment for the rarest jewels|Pressing distances me from you| |Presume that we each had a story that was true->removeEase)[1]\n(but I was long checked out of our hotel room|but fuck it I set the table for two| |that sometimes it takes years for softness to bloom->removeEase)[1]\n\n(Pl| Oranges fall to the ground as I rel| |Back then, I folded flower after flower, found myself in each->removeEase)[1]ease (Do Not Disturb| | | ->removeEase)[1]`;\nconst $98d79d017ae06d24$var$NUMBER_OF_POEMS = 4;\nconst $98d79d017ae06d24$var$container = document.querySelector(\".text\");\nconst $98d79d017ae06d24$var$pp = new (0, $9b061c90e4c8fb40$export$bb601a587602e2b4)($98d79d017ae06d24$var$container);\n$98d79d017ae06d24$var$pp.parse($98d79d017ae06d24$var$poem);\nfunction $98d79d017ae06d24$var$removeEase() {\n    debugger;\n    let allPlainText = document.querySelectorAll(\".proseplay-plaintext\");\n    let justEase = allPlainText[allPlainText.length - 1];\n    justEase.remove();\n}\naddEventListener(\"click\", (event)=>{\n    $98d79d017ae06d24$var$pp.currentIndexes.forEach((curr, index)=>{\n        $98d79d017ae06d24$var$pp.slideWindow(index, curr + 1);\n    // Ternery for special case on the last poem\n    // curr == NUMBER_OF_POEMS-1 ? removeEase() : ''\n    });\n});\n\n\n//# sourceMappingURL=index.3ceab00c.js.map\n","import { ProsePlay } from \"proseplay\";\n\nconst poem = `Press(ure|ing juice| |ume->removeEase)[1]\n\n\n(Absently|Anxiously| |Patiently->removeEase)[1] waiting for (cracks to show through|you to come through.| |me to come to->removeEase)[1]\n\n(Pressure creates the environment for the rarest jewels|Pressing distances me from you| |Presume that we each had a story that was true->removeEase)[1]\n(but I was long checked out of our hotel room|but fuck it I set the table for two| |that sometimes it takes years for softness to bloom->removeEase)[1]\n\n(Pl| Oranges fall to the ground as I rel| |Back then, I folded flower after flower, found myself in each->removeEase)[1]ease (Do Not Disturb| | | ->removeEase)[1]`;\n\nconst NUMBER_OF_POEMS = 4;\nconst container = document.querySelector(\".text\");\nconst pp = new ProsePlay(container);\npp.parse(poem);\n\nfunction removeEase() {\n    debugger;\n    let allPlainText = document.querySelectorAll(\".proseplay-plaintext\")\n    let justEase = allPlainText[allPlainText.length-1];\n    justEase.remove()\n}\n\naddEventListener(\"click\", (event) => {\n    pp.currentIndexes.forEach((curr, index) =>{\n        pp.slideWindow(index, curr + 1)\n        // Ternery for special case on the last poem\n        // curr == NUMBER_OF_POEMS-1 ? removeEase() : ''\n    })\n});","import \"./proseplay.css\";\n\n\nconst $97aedba7ab332eed$var$windowTemplate = document.createElement(\"div\");\n$97aedba7ab332eed$var$windowTemplate.classList.add(\"proseplay-window\");\nconst $97aedba7ab332eed$var$listTemplate = document.createElement(\"div\");\n$97aedba7ab332eed$var$listTemplate.classList.add(\"proseplay-list\");\n$97aedba7ab332eed$var$windowTemplate.append($97aedba7ab332eed$var$listTemplate);\nconst $97aedba7ab332eed$var$linkRefTemplate = document.createElement(\"sup\");\n$97aedba7ab332eed$var$linkRefTemplate.classList.add(\"proseplay-link-ref\");\nconst $97aedba7ab332eed$var$BUFFER_TIME = 15;\nlet $97aedba7ab332eed$var$PADDING;\nconst $97aedba7ab332eed$var$mouse = {\n    x: 0,\n    y: 0\n};\nclass $97aedba7ab332eed$export$cec157cbbbaf65c9 {\n    links = [];\n    horizontal = false;\n    constructor(parent){\n        this.el = $97aedba7ab332eed$var$windowTemplate.cloneNode(true);\n        parent.appendChild(this.el);\n        this.el.addEventListener(\"pointerover\", this.handlePointerOver);\n        this.el.addEventListener(\"pointerdown\", this.handlePointerDown);\n        this.el.addEventListener(\"pointermove\", this.handlePointerMove);\n        this.el.addEventListener(\"pointerup\", this.handlePointerUp);\n        this.el.addEventListener(\"pointerout\", this.handlePointerOut);\n        this.listEl = this.el.querySelector(\".proseplay-list\");\n        this.choices = [];\n        this.currentIndex = 0;\n        this.isHoverable = true;\n        this.isDragged = false;\n        this.linkIndex = null;\n        this.functionNames = [];\n        this.functions = {};\n        $97aedba7ab332eed$var$PADDING = parseInt(getComputedStyle(parent).fontSize) * 0.3;\n    }\n    /**\n   * Change the direction of the window to horizontal, i.e. east–west.\n   */ setHorizontal() {\n        this.horizontal = true;\n        this.el.classList.add(\"proseplay-horizontal\");\n    }\n    /**\n   * Add a choice to the window.\n   * @param choice The choice object to be added.\n   */ addChoice(choice) {\n        this.choices.push(choice);\n        this.listEl.appendChild(choice.el);\n    }\n    /**\n   * Activate the specified choice and adjusts position and sizing accordingly.\n   * @param choice The choice to be activated. If none is given, it readjusts to the current choice — this can be useful for resizing.\n   */ activateChoice(choice) {\n        if (!choice) {\n            choice = this.choices[this.currentIndex];\n            if (!this.horizontal) this.listEl.style.top = `-${choice.offsetTop}px`;\n            else this.listEl.style.left = `${-Math.abs(choice.offsetLeft) + $97aedba7ab332eed$var$PADDING}px`;\n        }\n        this.currentIndex = this.choices.indexOf(choice);\n        this.choices.forEach((otherChoice)=>otherChoice.deactivate());\n        choice.activate();\n        this.el.style.width = `${choice.offsetWidth}px`;\n    }\n    /**\n   * Get a random choice index.\n   * @returns The random chocie index.\n   */ random() {\n        return Math.floor(Math.random() * this.choices.length);\n    }\n    slideToPos(pos) {\n        if (!this.horizontal) this.listEl.style.top = `${pos}px`;\n        else this.listEl.style.left = `${pos}px`;\n        const targetChoice = this.getNearestChoice(pos);\n        if (!targetChoice) return;\n        this.activateChoice(targetChoice);\n    }\n    /**\n   * Slide to a specified index in the window's array of choices.\n   * @param choiceIndex Index of choice to slide to.\n   */ slideToChoice(choiceIndex, duration) {\n        if (choiceIndex > this.choices.length - 1) return;\n        const choice = this.choices[choiceIndex];\n        this.pointerOver();\n        this.pointerDown();\n        this.listEl.classList.add(\"proseplay-has-transition\");\n        this.listEl.addEventListener(\"transitionend\", (e)=>{\n            if (e.target !== this.listEl) return;\n            this.listEl.classList.remove(\"proseplay-has-transition\");\n        });\n        if (duration) {\n            this.listEl.style.transitionDuration = `${duration}ms`;\n            this.listEl.addEventListener(\"transitionend\", ()=>{\n                this.listEl.style.removeProperty(\"transition-duration\");\n            });\n            this.choices.forEach((choice)=>{\n                choice.el.style.transitionDuration = `${duration}ms`;\n                choice.el.addEventListener(\"transitionend\", ()=>{\n                    choice.el.style.removeProperty(\"transition-duration\");\n                });\n            });\n            this.el.style.transitionDuration = `${duration}ms`;\n            this.el.addEventListener(\"transitionend\", ()=>{\n                this.el.style.removeProperty(\"transition-duration\");\n            });\n        }\n        setTimeout(()=>{\n            if (!this.horizontal) this.listEl.style.top = `-${choice.offsetTop}px`;\n            else this.listEl.style.left = `${-Math.abs(choice.offsetLeft) + $97aedba7ab332eed$var$PADDING}px`;\n        }, $97aedba7ab332eed$var$BUFFER_TIME);\n        this.pointerUp();\n        this.pointerOut();\n        this.activateChoice(choice);\n    }\n    getNearestChoice(pos) {\n        let minDist = Infinity;\n        let targetChoice = null;\n        this.choices.forEach((choice)=>{\n            let dist = !this.horizontal ? Math.abs(pos + choice.offsetTop) : Math.abs(pos + choice.offsetLeft - $97aedba7ab332eed$var$PADDING);\n            if (dist < minDist) {\n                minDist = dist;\n                targetChoice = choice;\n            }\n        });\n        return targetChoice;\n    }\n    snapToNearestChoice() {\n        const choice = this.getNearestChoice(this.pos);\n        if (!choice) return;\n        if (!this.horizontal) this.listEl.style.top = `-${choice.offsetTop}px`;\n        else this.listEl.style.left = `${-Math.abs(choice.offsetLeft) + $97aedba7ab332eed$var$PADDING}px`;\n    }\n    /**\n   * Return either the `left` or `top` of the window's list element, depending on the direction of the window.\n   */ get pos() {\n        const property = this.horizontal ? \"left\" : \"top\";\n        return parseInt(getComputedStyle(this.listEl).getPropertyValue(property).replace(\"px\", \"\"));\n    }\n    handlePointerOver = (e)=>{\n        e.preventDefault();\n        if (!this.isHoverable) return;\n        const target = e.target;\n        if (!target.classList.contains(\"proseplay-current\")) return;\n        this.el.closest(\".proseplay\").querySelectorAll(\".proseplay-line\").forEach((line)=>{\n            line.classList.add(\"proseplay-has-hover\");\n        });\n        this.pointerOver();\n    };\n    pointerOver() {\n        this.el.classList.add(\"proseplay-hover\");\n    }\n    handlePointerDown = (e)=>{\n        e.preventDefault();\n        if (!this.isHoverable) return;\n        const target = e.target;\n        if (!target.classList.contains(\"proseplay-current\")) return;\n        this.el.setPointerCapture(e.pointerId);\n        this.links.forEach((window)=>window.pointerDown());\n        this.isDragged = true;\n        $97aedba7ab332eed$var$mouse.x = e.clientX;\n        $97aedba7ab332eed$var$mouse.y = e.clientY;\n    };\n    pointerDown() {\n        this.el.classList.add(\"proseplay-hover\");\n    }\n    handlePointerMove = (e)=>{\n        e.preventDefault();\n        if (!this.isDragged) return;\n        const dist = !this.horizontal ? $97aedba7ab332eed$var$mouse.y - e.clientY : $97aedba7ab332eed$var$mouse.x - e.clientX;\n        this.slideToPos(this.pos - dist);\n        this.links.forEach((window)=>{\n            window.slideToPos(this.pos - dist);\n        });\n        $97aedba7ab332eed$var$mouse.x = e.clientX;\n        $97aedba7ab332eed$var$mouse.y = e.clientY;\n    };\n    handlePointerOut = ()=>{\n        if (this.isDragged) return;\n        this.el.closest(\".proseplay\").querySelectorAll(\".proseplay-line\").forEach((line)=>{\n            line.classList.remove(\"proseplay-has-hover\");\n        });\n        this.pointerOut();\n        this.links.forEach((window)=>window.pointerOut());\n    };\n    pointerOut() {\n        this.isDragged = false;\n        this.el.classList.remove(\"proseplay-hover\");\n    }\n    handlePointerUp = (e)=>{\n        e.preventDefault();\n        this.pointerUp();\n        this.links.forEach((window)=>window.pointerUp());\n    };\n    pointerUp() {\n        this.snapToNearestChoice();\n        this.isDragged = false;\n        this.el.classList.remove(\"proseplay-hover\");\n        let functionName = this.functionNames[this.currentIndex];\n        if (functionName) {\n            if (this.functions[functionName]) this.functions[functionName]();\n        }\n        this.el.closest(\".proseplay\").querySelectorAll(\".proseplay-line\").forEach((line)=>{\n            line.classList.remove(\"proseplay-has-hover\");\n        });\n    }\n    /**\n   * Set link between this window and other windows.\n   * @param linkIndex Index number of link, as indicated in square brackets.\n   * @param otherWindows Array of other windows in the same link.\n   */ setLink(linkIndex, otherWindows) {\n        this.linkIndex = linkIndex;\n        if (linkIndex) {\n            const sup = $97aedba7ab332eed$var$linkRefTemplate.cloneNode(true);\n            this.el.insertAdjacentElement(\"afterend\", sup);\n            sup.innerText = `${linkIndex}`;\n        }\n        this.links = otherWindows;\n    }\n    /**\n   * Set function names.\n   * @param functionNames Array of function names.\n   */ setFunctionNames(functionNames) {\n        this.functionNames = functionNames;\n    }\n    /**\n   * Assign functions to function names.\n   * @param name Name of function.\n   * @param fnc Function to be called.\n   */ setFunction(name, fnc) {\n        this.functions[name] = fnc;\n    }\n}\n\n\nconst $fb2114d596aef9c8$var$choiceTemplate = document.createElement(\"div\");\n$fb2114d596aef9c8$var$choiceTemplate.classList.add(\"proseplay-choice\");\nclass $fb2114d596aef9c8$export$32a7462f6a06cbd5 {\n    text = \"\";\n    isCurrent = false;\n    constructor(text){\n        this.text = text;\n        this.el = $fb2114d596aef9c8$var$choiceTemplate.cloneNode(true);\n        if (text !== \" \") this.el.innerText = text;\n        else this.el.innerHTML = \"&thinsp;\";\n    }\n    /**\n   * Activate this choice.\n   */ activate() {\n        this.isCurrent = true;\n        this.el.classList.add(\"proseplay-current\");\n    }\n    /**\n   * Deactivate this choice.\n   */ deactivate() {\n        this.isCurrent = false;\n        this.el.classList.remove(\"proseplay-current\");\n    }\n    /**\n   * Get the `offsetTop` of this element.\n   */ get offsetTop() {\n        return this.el.offsetTop;\n    }\n    /**\n   * Get the `offsetLeft` of this element.\n   */ get offsetLeft() {\n        return this.el.offsetLeft;\n    }\n    /**\n   * Get the `offsetWidth` of this element.\n   */ get offsetWidth() {\n        return this.el.offsetWidth;\n    }\n}\n\n\nconst $79098f0a1478fa01$var$lineTemplate = document.createElement(\"div\");\n$79098f0a1478fa01$var$lineTemplate.classList.add(\"proseplay-line\");\nconst $79098f0a1478fa01$var$samples = {\n    dickinson: `We talked with each other about each other\nThough neither of us spoke —\nWe were (too engrossed with|listening to) the Second’s Races\nAnd the Hoofs of the Clock —\nPausing in Front of our (Sentenced Faces|Foundering Faces)\n(Time’s Decision shook —|Time compassion Took)\nArks of Reprieve he offered to us —\nArarats — we took —`,\n    homophones: `in the (mist|missed) (see|sea)\n(prey|pray) in the (morning|mourning)\nfor (words|worlds) that (exit|exist)\nas (seep|sleep)`,\n    hypothetically: `(hypothetically|hello)[1-]\n(what if|i said)[1-]\n(we fell|and held)[1-]\n(in love|till death)[1-]`\n};\nlet $79098f0a1478fa01$var$EM;\nclass $79098f0a1478fa01$export$bb601a587602e2b4 {\n    lines = [];\n    windows = [];\n    links = [];\n    _isExpanded = false;\n    functions = {};\n    /**\n   * Create a new ProsePlay object, which will be contained in the given HTML element.\n   * @param el The HTML element in which the ProsePlay instance will be contained.\n   */ constructor(el){\n        this.el = el;\n        this.el.classList.add(\"proseplay\");\n        window.addEventListener(\"resize\", this.handleResize);\n        document.addEventListener(\"DOMContentLoaded\", this.handleResize);\n        $79098f0a1478fa01$var$EM = parseInt(getComputedStyle(el).fontSize);\n    }\n    static createInstance() {\n        const container = document.createElement(\"div\");\n        container.classList.add(\"proseplay\");\n        document.body.appendChild(container);\n        const pp = new $79098f0a1478fa01$export$bb601a587602e2b4(container);\n        return pp;\n    }\n    /**\n   * Load a sample.\n   * @param name The name of the sample to load.\n   * @returns The ProsePlay instance with the parsed text.\n   */ load(name) {\n        this.lines = [];\n        this.windows = [];\n        this.links = [];\n        return this.parse($79098f0a1478fa01$var$samples[name]);\n    }\n    /**\n   * Create a ProsePlay instance and load a sample.\n   * @param name The name of the sample to load.\n   * @returns A ProsePlay instance with the parsed text.\n   */ static load(name) {\n        const pp = $79098f0a1478fa01$export$bb601a587602e2b4.createInstance();\n        return pp.load(name);\n    }\n    /**\n   * Parse the given string.\n   * @param str The formatted string to parse.\n   * @returns The ProsePlay instance with the parsed text.\n   */ parse(str) {\n        this.lines = [];\n        this.windows = [];\n        this.links = [];\n        str = str.trim();\n        let textTokens = [];\n        let lines = str.split(\"\\n\");\n        lines.forEach((line)=>{\n            const lineTokens = [];\n            let m = line.matchAll(new RegExp(\"\\\\(([^(|)]+\\\\|([^(|)]+\\\\|?)+)\\\\)(\\\\[(\\\\d)*(-)?\\\\])?\" // link index\n            , \"g\"));\n            const stringsIndex = 1, linkIndex = 4, orientationIndex = 5;\n            let currIndex = 0;\n            for (const match of m){\n                const index = match.index;\n                let isEscaped = line[index - 2] === \"\\\\\";\n                let prevToken = {\n                    strings: []\n                }, currentToken = {\n                    strings: []\n                };\n                if (isEscaped) {\n                    prevToken.strings = [\n                        line.slice(currIndex, index - 1)\n                    ];\n                    currentToken.strings = [\n                        line.slice(index, index + match[0].length)\n                    ];\n                } else {\n                    prevToken.strings = [\n                        line.slice(currIndex, index)\n                    ];\n                    currentToken.strings = match[stringsIndex].split(\"|\");\n                    currentToken.strings.forEach((str, i)=>{\n                        let [s, fnc] = str.split(\"->\");\n                        if (fnc) {\n                            if (!currentToken.functionNames) currentToken.functionNames = [];\n                            currentToken.functionNames[i] = fnc;\n                            currentToken.strings[i] = s;\n                        }\n                    });\n                    if (match[linkIndex]) currentToken.linkIndex = parseInt(match[linkIndex]);\n                    if (match[orientationIndex] && (match[orientationIndex] === \"|\" || match[orientationIndex] === \"-\")) currentToken.horizontal = match[orientationIndex] === \"-\";\n                }\n                lineTokens.push(prevToken);\n                lineTokens.push(currentToken);\n                currIndex = index + match[0].length;\n            }\n            if (currIndex < line.length) lineTokens.push({\n                strings: [\n                    line.slice(currIndex)\n                ]\n            });\n            textTokens.push(lineTokens);\n        });\n        this.constructText(textTokens);\n        return this;\n    }\n    /**\n   * Create a new ProsePlay instance and parse the given string.\n   * @param str The formatted string to parse.\n   * @returns A ProsePlay instance with the parsed text.\n   */ static parse(str) {\n        const pp = $79098f0a1478fa01$export$bb601a587602e2b4.createInstance();\n        pp.parse(str);\n        return pp;\n    }\n    constructText(text) {\n        this.el.innerHTML = \"\";\n        text.forEach((line)=>{\n            const lineEl = $79098f0a1478fa01$var$lineTemplate.cloneNode(true);\n            this.el.appendChild(lineEl);\n            this.lines.push({\n                el: lineEl,\n                tokens: [],\n                windows: []\n            });\n            line.forEach((token)=>{\n                if (token.strings.length === 1) {\n                    const span = document.createElement(\"span\");\n                    span.classList.add(\"proseplay-plaintext\");\n                    span.innerText = token.strings[0];\n                    lineEl.append(span);\n                    this.lines[this.lines.length - 1].tokens.push(token.strings[0]);\n                } else {\n                    const window1 = new (0, $97aedba7ab332eed$export$cec157cbbbaf65c9)(lineEl);\n                    if (token.linkIndex) {\n                        if (!this.links[token.linkIndex]) this.links[token.linkIndex] = [];\n                        this.links[token.linkIndex].push(window1);\n                    }\n                    if (token.functionNames) window1.setFunctionNames(token.functionNames);\n                    for(const name in this.functions)window1.setFunction(name, this.functions[name]);\n                    if (token.horizontal) window1.setHorizontal();\n                    this.lines[this.lines.length - 1].tokens.push(window1);\n                    this.lines[this.lines.length - 1].windows.push(window1);\n                    this.windows.push(window1);\n                    token.strings.forEach((str)=>window1.addChoice(new (0, $fb2114d596aef9c8$export$32a7462f6a06cbd5)(str)));\n                    window1.activateChoice(window1.choices[0]);\n                }\n            });\n            if (line.length === 0) lineEl.innerHTML = \"&nbsp;\";\n        });\n        this.links.forEach((windows, i)=>{\n            windows.forEach((window1)=>{\n                const otherWindows = windows.filter((otherWindow)=>otherWindow !== window1);\n                window1.setLink(i, otherWindows);\n            });\n        });\n    }\n    /**\n   * Slide each window to a random choice. If windows are linked, they will move to the same choice index together. If no `windowIndexes` is specified, all windows will be randomised.\n   */ randomise(options) {\n        if (this._isExpanded) return;\n        const windowIndexes = options?.windowIndexes || this.windows.map((_, i)=>i);\n        let windowsDragged = [];\n        windowIndexes.forEach((i)=>{\n            const window1 = this.windows[i];\n            if (!window1) return;\n            if (windowsDragged.includes(window1)) return;\n            let choiceIndex = window1.random();\n            window1.slideToChoice(choiceIndex, options?.millis);\n            windowsDragged.push(window1);\n            if (window1.linkIndex) this.links[window1.linkIndex].forEach((otherWindow)=>{\n                if (windowsDragged.includes(otherWindow)) return;\n                otherWindow.slideToChoice(choiceIndex, options?.millis);\n                windowsDragged.push(otherWindow);\n            });\n        });\n    }\n    /**\n   * Alias for `randomise()`.\n   * @param windowIndexes An optional list of window indexes to randomise.\n   */ randomize(options) {\n        this.randomise(options);\n    }\n    /**\n   * Expand all windows to show all choices at once. When this is enabled, all other interactions are disabled until `collapse()` is called.\n   */ expand() {\n        this._isExpanded = true;\n        this.el.classList.toggle(\"proseplay-is-expanded\", this._isExpanded);\n        const em = parseFloat(getComputedStyle(this.el).fontSize);\n        this.lines.forEach((line)=>{\n            let marginBottom = 0;\n            line.windows.forEach((window1)=>{\n                let height = window1.el.scrollHeight - window1.listEl.offsetTop;\n                window1.el.style.height = `${height}px`;\n                let y = window1.el.scrollHeight - (window1.currentIndex + 1) * 1.25 * em - 0.06 * em;\n                window1.el.style.top = `${y}px`;\n                window1.el.style.marginTop = `${-y}px`;\n                marginBottom = Math.max(marginBottom, y);\n                window1.listEl.style.top = \"0px\";\n                let maxWidth = 0;\n                window1.choices.forEach((choice, i)=>{\n                    choice.el.style.opacity = \"1\";\n                    if (!window1.horizontal) maxWidth = Math.max(maxWidth, choice.el.offsetWidth);\n                    else {\n                        if (i > 0) maxWidth += $79098f0a1478fa01$var$EM;\n                        maxWidth += choice.el.offsetWidth;\n                    }\n                });\n                window1.el.style.width = `${maxWidth}px`;\n                window1.isHoverable = false;\n            });\n            line.el.style.marginBottom = `${marginBottom}px`;\n        });\n    }\n    /**\n   * Collapse all windows.\n   */ collapse() {\n        this._isExpanded = false;\n        this.el.classList.toggle(\"proseplay-is-expanded\", this._isExpanded);\n        this.lines.forEach((line)=>{\n            line.el.style.removeProperty(\"margin-bottom\");\n            line.windows.forEach((window1)=>{\n                window1.el.style.removeProperty(\"height\");\n                window1.el.style.removeProperty(\"top\");\n                window1.el.style.removeProperty(\"margin-top\");\n                window1.listEl.style.removeProperty(\"top\");\n                window1.choices.forEach((choice)=>{\n                    choice.el.style.removeProperty(\"opacity\");\n                });\n                window1.listEl.style.removeProperty(\"width\");\n                window1.isHoverable = true;\n                window1.activateChoice();\n            });\n        });\n    }\n    /**\n   * Check if windows are expanded or collapsed.\n   * @returns A boolean representing whether windows are expanded (true) or collapsed (false).\n   */ get isExpanded() {\n        return this._isExpanded;\n    }\n    /**\n   * Return the current text.\n   * @returns A string of the current text.\n   */ snapshot() {\n        let text = \"\";\n        this.lines.forEach((line)=>{\n            line.tokens.forEach((token)=>{\n                if (token instanceof (0, $97aedba7ab332eed$export$cec157cbbbaf65c9)) text += token.choices[token.currentIndex].text;\n                else text += token;\n            });\n            text += \"\\n\";\n        });\n        return text;\n    }\n    /**\n   * Set function to be called when certain choices are selected.\n   * @param name Name of function.\n   * @param fnc Function to be called.\n   */ setFunction(name, fnc) {\n        this.functions[name] = fnc;\n        this.windows.forEach((window1)=>window1.setFunction(name, fnc));\n    }\n    handleResize = ()=>{\n        this.windows.forEach((window1)=>window1.activateChoice());\n    };\n    /**\n   * Return a nested list of choices in each window.\n   */ get choices() {\n        return this.windows.map((window1)=>{\n            return window1.choices.map((choice)=>choice.text);\n        });\n    }\n    /**\n   * Return a list of indexes to which each window is currently set.\n   */ get currentIndexes() {\n        return this.windows.map((window1)=>window1.currentIndex);\n    }\n    /**\n   * Slide a specified window to a specified choice.\n   * @param windowIndex The index of the window to slide.\n   * @param choiceIndex The index of the choice to slide to.\n   */ slideWindow(windowIndex, choiceIndex, options) {\n        if (windowIndex > this.windows.length - 1) return;\n        const window1 = this.windows[windowIndex];\n        if (choiceIndex > window1.choices.length - 1) return;\n        window1.slideToChoice(choiceIndex, options?.millis);\n    }\n}\n\n\nexport {$79098f0a1478fa01$export$bb601a587602e2b4 as ProsePlay};\n//# sourceMappingURL=proseplay-module.js.map\n","import \"./proseplay.less\";\n\nimport { Window } from \"./window\";\nimport { Choice } from \"./choice\";\n\ntype Token = {\n  strings: string[]\n  linkIndex?: number | null,\n  horizontal?: boolean,\n  functionNames?: string[]\n};\ntype TokenizedLine = Token[];\ntype TokenizedText = TokenizedLine[];\n\nconst lineTemplate = document.createElement(\"div\");\nlineTemplate.classList.add(\"proseplay-line\");\n\nconst samples = {\n  dickinson: `We talked with each other about each other\nThough neither of us spoke —\nWe were (too engrossed with|listening to) the Second’s Races\nAnd the Hoofs of the Clock —\nPausing in Front of our (Sentenced Faces|Foundering Faces)\n(Time’s Decision shook —|Time compassion Took)\nArks of Reprieve he offered to us —\nArarats — we took —`,\n  homophones: `in the (mist|missed) (see|sea)\n(prey|pray) in the (morning|mourning)\nfor (words|worlds) that (exit|exist)\nas (seep|sleep)`,\n  hypothetically: `(hypothetically|hello)[1-]\n(what if|i said)[1-]\n(we fell|and held)[1-]\n(in love|till death)[1-]`\n};\n\nlet EM: number;\n\nclass ProsePlay {\n  private el: HTMLElement;\n\n  private lines: {\n    el: HTMLElement,\n    tokens: (string | Window)[],\n    windows: Window[]\n  }[] = [];\n  private windows: Window[] = [];\n  private links: Window[][] = [];\n\n  private _isExpanded: boolean = false;\n\n  private functions: {\n    [name: string]: Function\n  } = {};\n\n  /**\n   * Create a new ProsePlay object, which will be contained in the given HTML element.\n   * @param el The HTML element in which the ProsePlay instance will be contained.\n   */\n  constructor(el: HTMLElement) {\n    this.el = el;\n    this.el.classList.add(\"proseplay\");\n    window.addEventListener(\"resize\", this.handleResize);\n    document.addEventListener(\"DOMContentLoaded\", this.handleResize);\n\n    EM = parseInt(getComputedStyle(el).fontSize);\n  }\n\n  private static createInstance(): ProsePlay {\n    const container = document.createElement(\"div\");\n    container.classList.add(\"proseplay\");\n    document.body.appendChild(container);\n    const pp = new ProsePlay(container);\n    return pp;\n  }\n\n  /**\n   * Load a sample.\n   * @param name The name of the sample to load.\n   * @returns The ProsePlay instance with the parsed text.\n   */\n  load(name: \"homophones\" | \"hypothetically\" | \"dickinson\"): ProsePlay {\n    this.lines = [];\n    this.windows = [];\n    this.links = [];\n\n    return this.parse(samples[name]);\n  }\n\n  /**\n   * Create a ProsePlay instance and load a sample.\n   * @param name The name of the sample to load.\n   * @returns A ProsePlay instance with the parsed text.\n   */\n  static load(name: \"homophones\" | \"hypothetically\" | \"dickinson\"): ProsePlay {\n    const pp = ProsePlay.createInstance();\n    return pp.load(name);\n  }\n\n  /**\n   * Parse the given string.\n   * @param str The formatted string to parse.\n   * @returns The ProsePlay instance with the parsed text.\n   */\n  parse(str: string): ProsePlay {\n    this.lines = [];\n    this.windows = [];\n    this.links = [];\n\n    str = str.trim();\n    let textTokens: TokenizedText = [];\n    let lines = str.split(\"\\n\");\n    lines.forEach(line => {\n      const lineTokens: TokenizedLine = [];\n      let m = line.matchAll(new RegExp(\n        \"\\\\(\" + // open parentheses\n          \"(\" + // start capturing group\n            \"[^(|)]+\" + // first string\n            \"\\\\|\" + // pipe\n            \"([^(|)]+\\\\|?)+\" + // one or more strings, with optional pipe\n          \")\" + // end capturing group\n        \"\\\\)\" + // close parentheses\n        \"(\\\\[(\\\\d)*(-)?\\\\])?\" // link index\n        , \"g\"));\n      const stringsIndex = 1,\n        linkIndex = 4,\n        orientationIndex = 5;\n\n      let currIndex = 0;\n      for (const match of m) {\n        const index = match.index as number;\n        let isEscaped = line[index - 2] === \"\\\\\";\n\n        let prevToken: Token = {strings: []},\n          currentToken: Token = {strings: []};\n        if (isEscaped) {\n          prevToken.strings = [line.slice(currIndex, index - 1)];\n          currentToken.strings = [line.slice(index, index + match[0].length)];\n        } else {\n          prevToken.strings = [line.slice(currIndex, index)];\n          currentToken.strings = match[stringsIndex].split(\"|\");\n          currentToken.strings.forEach((str, i) => {\n            let [s, fnc] = str.split(\"->\");\n            if (fnc) {\n              if (!currentToken.functionNames) {\n                currentToken.functionNames = [];\n              }\n              currentToken.functionNames[i] = fnc;\n\n              currentToken.strings[i] = s;\n            }\n          });\n          if (match[linkIndex]) {\n            currentToken.linkIndex = parseInt(match[linkIndex]);\n          }\n          if (match[orientationIndex] && (match[orientationIndex] === \"|\" || match[orientationIndex] === \"-\")) {\n            currentToken.horizontal = match[orientationIndex] === \"-\";\n          }\n        }\n        lineTokens.push(prevToken);\n        lineTokens.push(currentToken);\n\n        currIndex = index + match[0].length;\n      }\n      if (currIndex < line.length) {\n        lineTokens.push({strings: [line.slice(currIndex)]});\n      }\n      textTokens.push(lineTokens);\n    });\n  \n    this.constructText(textTokens);\n\n    return this;\n  }\n\n  /**\n   * Create a new ProsePlay instance and parse the given string.\n   * @param str The formatted string to parse.\n   * @returns A ProsePlay instance with the parsed text.\n   */\n  static parse(str: string): ProsePlay {\n    const pp = ProsePlay.createInstance();\n    pp.parse(str);\n    return pp;\n  }\n  \n  private constructText(text: TokenizedText): void {\n    this.el.innerHTML = \"\";\n    text.forEach(line => {\n      const lineEl = lineTemplate.cloneNode(true) as HTMLElement;\n      this.el.appendChild(lineEl);\n      this.lines.push({\n        el: lineEl,\n        tokens: [],\n        windows: []\n      });\n\n      line.forEach(token => {\n        if (token.strings.length === 1) {\n          const span = document.createElement(\"span\");\n          span.classList.add(\"proseplay-plaintext\");\n          span.innerText = token.strings[0];\n          lineEl.append(span);\n          this.lines[this.lines.length - 1].tokens.push(token.strings[0]);\n        } else {\n          const window = new Window(lineEl);\n          if (token.linkIndex) {\n            if (!this.links[token.linkIndex]) {\n              this.links[token.linkIndex] = [];\n            }\n            this.links[token.linkIndex].push(window);\n          }\n          if (token.functionNames) {\n            window.setFunctionNames(token.functionNames);\n          }\n          for (const name in this.functions) {\n            window.setFunction(name, this.functions[name]);\n          }\n          if (token.horizontal) {\n            window.setHorizontal();\n          }\n          this.lines[this.lines.length - 1].tokens.push(window);\n          this.lines[this.lines.length - 1].windows.push(window);\n          this.windows.push(window);\n          token.strings.forEach(str => window.addChoice(new Choice(str)));\n          window.activateChoice(window.choices[0]);\n        }\n      });\n      if (line.length === 0) {\n        lineEl.innerHTML = \"&nbsp;\";\n      }\n    });\n\n    this.links.forEach((windows, i) => {\n      windows.forEach(window => {\n        const otherWindows = windows.filter(otherWindow => otherWindow !== window);\n        window.setLink(i, otherWindows);\n      });\n    });\n  }\n\n  /**\n   * Slide each window to a random choice. If windows are linked, they will move to the same choice index together. If no `windowIndexes` is specified, all windows will be randomised.\n   */\n  randomise(options?: { windowIndexes?: number[], millis?: number }): void {\n    if (this._isExpanded) return;\n\n    const windowIndexes = options?.windowIndexes || this.windows.map((_, i) => i);\n    \n    let windowsDragged: Window[] = [];\n    windowIndexes.forEach(i => {\n      const window = this.windows[i];\n      if (!window) return;\n\n      if (windowsDragged.includes(window)) return;\n\n      let choiceIndex = window.random();\n      window.slideToChoice(choiceIndex, options?.millis);\n      windowsDragged.push(window);\n      if (window.linkIndex) {\n        this.links[window.linkIndex].forEach(otherWindow => {\n          if (windowsDragged.includes(otherWindow)) return;\n          otherWindow.slideToChoice(choiceIndex, options?.millis);\n          windowsDragged.push(otherWindow);\n        });\n      }\n    });\n  }\n\n  /**\n   * Alias for `randomise()`.\n   * @param windowIndexes An optional list of window indexes to randomise.\n   */\n  randomize(options?: { windowIndexes?: number[], millis?: number }): void {\n    this.randomise(options);\n  }\n\n  /**\n   * Expand all windows to show all choices at once. When this is enabled, all other interactions are disabled until `collapse()` is called.\n   */\n  expand(): void {\n    this._isExpanded = true;\n    this.el.classList.toggle(\"proseplay-is-expanded\", this._isExpanded);\n\n    const em = parseFloat(getComputedStyle(this.el).fontSize);\n    \n    this.lines.forEach(line => {\n      let marginBottom = 0;\n\n      line.windows.forEach(window => {\n        let height = window.el.scrollHeight - window.listEl.offsetTop;\n        window.el.style.height = `${height}px`;\n        \n        let y = window.el.scrollHeight - (window.currentIndex + 1) * 1.25 * em - 0.06 * em;\n        window.el.style.top = `${y}px`;\n        window.el.style.marginTop = `${-y}px`;\n        marginBottom = Math.max(marginBottom, y);\n\n        window.listEl.style.top = \"0px\";\n\n        let maxWidth = 0;\n        window.choices.forEach((choice, i) => {\n          choice.el.style.opacity = \"1\";\n          if (!window.horizontal) {\n            maxWidth = Math.max(maxWidth, choice.el.offsetWidth);\n          } else {\n            if (i > 0) {\n              maxWidth += EM;\n            }\n            maxWidth += choice.el.offsetWidth;\n          }\n        });\n        window.el.style.width = `${maxWidth}px`;\n\n        window.isHoverable = false;\n      });\n\n      line.el.style.marginBottom = `${marginBottom}px`;\n    });\n  }\n\n  /**\n   * Collapse all windows.\n   */\n  collapse(): void {\n    this._isExpanded = false;\n    this.el.classList.toggle(\"proseplay-is-expanded\", this._isExpanded);\n\n    this.lines.forEach(line => {\n      line.el.style.removeProperty(\"margin-bottom\");\n\n      line.windows.forEach(window => {\n        window.el.style.removeProperty(\"height\");\n        window.el.style.removeProperty(\"top\");\n        window.el.style.removeProperty(\"margin-top\");\n        window.listEl.style.removeProperty(\"top\");\n        window.choices.forEach(choice => {\n          choice.el.style.removeProperty(\"opacity\");\n        });\n        window.listEl.style.removeProperty(\"width\");\n\n        window.isHoverable = true;\n\n        window.activateChoice();\n      });\n    });\n  }\n\n  /**\n   * Check if windows are expanded or collapsed.\n   * @returns A boolean representing whether windows are expanded (true) or collapsed (false).\n   */\n  get isExpanded(): boolean {\n    return this._isExpanded;\n  }\n\n  /**\n   * Return the current text.\n   * @returns A string of the current text.\n   */\n  snapshot(): string {\n    let text = \"\";\n    this.lines.forEach(line => {\n      line.tokens.forEach(token => {\n        if (token instanceof Window) {\n          text += token.choices[token.currentIndex].text;\n        } else {\n          text += token;\n        }\n      })\n      text += \"\\n\";\n    });\n\n    return text;\n  }\n\n  /**\n   * Set function to be called when certain choices are selected.\n   * @param name Name of function.\n   * @param fnc Function to be called.\n   */\n  setFunction(name: string, fnc: Function): void {\n    this.functions[name] = fnc;\n    this.windows.forEach(window => window.setFunction(name, fnc));\n  }\n\n  private handleResize = (): void => {\n    this.windows.forEach(window => window.activateChoice());\n  }\n\n  /**\n   * Return a nested list of choices in each window.\n   */\n  get choices(): string[][] {\n    return this.windows.map(window => {\n      return window.choices.map(choice => choice.text);\n    });\n  }\n\n  /**\n   * Return a list of indexes to which each window is currently set.\n   */\n  get currentIndexes(): number[] {\n    return this.windows.map(window => window.currentIndex);\n  }\n\n  /**\n   * Slide a specified window to a specified choice.\n   * @param windowIndex The index of the window to slide.\n   * @param choiceIndex The index of the choice to slide to.\n   */\n  slideWindow(windowIndex: number, choiceIndex: number, options?: { millis?: number }): void {\n    if (windowIndex > this.windows.length - 1) return;\n    const window = this.windows[windowIndex];\n    if (choiceIndex > window.choices.length - 1) return;\n    window.slideToChoice(choiceIndex, options?.millis);\n  }\n}\n\nexport { ProsePlay }","import { Choice } from \"./choice\";\n\nconst windowTemplate = document.createElement(\"div\");\nwindowTemplate.classList.add(\"proseplay-window\");\nconst listTemplate = document.createElement(\"div\");\nlistTemplate.classList.add(\"proseplay-list\");\nwindowTemplate.append(listTemplate);\n\nconst linkRefTemplate = document.createElement(\"sup\");\nlinkRefTemplate.classList.add(\"proseplay-link-ref\");\n\nconst BUFFER_TIME = 15;\nlet PADDING: number;\n\nconst mouse = { x: 0, y: 0 };\n\nclass Window {\n  el: HTMLElement;\n  listEl: HTMLElement;\n\n  choices: Choice[];\n  currentIndex: number;\n\n  isHoverable: boolean;\n  private isDragged: boolean;\n\n  linkIndex: number | null;\n  private links: Window[] = [];\n\n  functionNames: string[];\n  functions: {\n    [name: string]: Function\n  };\n\n  horizontal: boolean = false;\n\n  constructor(parent: HTMLElement) {\n    this.el = windowTemplate.cloneNode(true) as HTMLElement;\n    parent.appendChild(this.el);\n\n    this.el.addEventListener(\"pointerover\", this.handlePointerOver);\n    this.el.addEventListener(\"pointerdown\", this.handlePointerDown);\n    this.el.addEventListener(\"pointermove\", this.handlePointerMove);\n    this.el.addEventListener(\"pointerup\", this.handlePointerUp);\n    this.el.addEventListener(\"pointerout\", this.handlePointerOut);\n\n    this.listEl = this.el.querySelector(\".proseplay-list\") as HTMLElement;\n\n    this.choices = [];\n    this.currentIndex = 0;\n\n    this.isHoverable = true;\n    this.isDragged = false;\n\n    this.linkIndex = null;\n\n    this.functionNames = [];\n    this.functions = {};\n\n    PADDING = parseInt(getComputedStyle(parent).fontSize) * 0.3;\n  }\n\n  /**\n   * Change the direction of the window to horizontal, i.e. east–west.\n   */\n  setHorizontal(): void {\n    this.horizontal = true;\n    this.el.classList.add(\"proseplay-horizontal\");\n  }\n\n  /**\n   * Add a choice to the window.\n   * @param choice The choice object to be added.\n   */\n  addChoice(choice: Choice): void {\n    this.choices.push(choice);\n    this.listEl.appendChild(choice.el);\n  }\n\n  /**\n   * Activate the specified choice and adjusts position and sizing accordingly.\n   * @param choice The choice to be activated. If none is given, it readjusts to the current choice — this can be useful for resizing.\n   */\n  activateChoice(choice?: Choice): void {\n    if (!choice) {\n      choice = this.choices[this.currentIndex];\n      if (!this.horizontal) {\n        this.listEl.style.top = `-${choice.offsetTop}px`;\n      } else {\n        this.listEl.style.left = `${-Math.abs(choice.offsetLeft) + PADDING}px`;\n      }\n    }\n    this.currentIndex = this.choices.indexOf(choice);\n    this.choices.forEach(otherChoice => otherChoice.deactivate());\n    choice.activate();\n    this.el.style.width = `${choice.offsetWidth}px`;\n  }\n\n  /**\n   * Get a random choice index.\n   * @returns The random chocie index.\n   */\n  random(): number {\n    return Math.floor(Math.random() * this.choices.length);\n  }\n\n  private slideToPos(pos: number): void {\n    if (!this.horizontal) {\n      this.listEl.style.top = `${pos}px`;\n    } else {\n      this.listEl.style.left = `${pos}px`;\n    }\n\n    const targetChoice = this.getNearestChoice(pos);\n    if (!targetChoice) return;\n\n    this.activateChoice(targetChoice);\n  }\n\n  /**\n   * Slide to a specified index in the window's array of choices.\n   * @param choiceIndex Index of choice to slide to.\n   */\n  slideToChoice(choiceIndex: number, duration?: number) {\n    if (choiceIndex > this.choices.length - 1) return;\n    const choice = this.choices[choiceIndex];\n\n    this.pointerOver();\n    this.pointerDown();\n\n    this.listEl.classList.add(\"proseplay-has-transition\");\n    this.listEl.addEventListener(\"transitionend\", e => {\n      if (e.target !== this.listEl) return;\n      this.listEl.classList.remove(\"proseplay-has-transition\");\n    });\n\n    if (duration) {\n      this.listEl.style.transitionDuration = `${duration}ms`;\n      this.listEl.addEventListener(\"transitionend\", () => {\n        this.listEl.style.removeProperty(\"transition-duration\");\n      });\n\n      this.choices.forEach(choice => {\n        choice.el.style.transitionDuration = `${duration}ms`;\n        choice.el.addEventListener(\"transitionend\", () => {\n          choice.el.style.removeProperty(\"transition-duration\");\n        });\n      });\n\n      this.el.style.transitionDuration = `${duration}ms`;\n      this.el.addEventListener(\"transitionend\", () => {\n        this.el.style.removeProperty(\"transition-duration\");\n      });\n    }\n\n    setTimeout(() => {\n      if (!this.horizontal) {\n        this.listEl.style.top = `-${choice.offsetTop}px`;\n      } else {\n        this.listEl.style.left = `${-Math.abs(choice.offsetLeft) + PADDING}px`;\n      }\n    }, BUFFER_TIME);\n\n    this.pointerUp();\n    this.pointerOut();\n\n    this.activateChoice(choice);\n  }\n\n  private getNearestChoice(pos: number): Choice | null {\n    let minDist = Infinity;\n    let targetChoice: Choice | null = null;\n    this.choices.forEach(choice => {\n      let dist = !this.horizontal ? Math.abs(pos + choice.offsetTop) : Math.abs(pos + choice.offsetLeft - PADDING);\n      if (dist < minDist) {\n        minDist = dist;\n        targetChoice = choice;\n      }\n    });\n    return targetChoice;\n  }\n\n  private snapToNearestChoice(): void {\n    const choice = this.getNearestChoice(this.pos);\n    if (!choice) return;\n    if (!this.horizontal) {\n      this.listEl.style.top = `-${choice.offsetTop}px`;\n    } else {\n      this.listEl.style.left = `${-Math.abs(choice.offsetLeft) + PADDING}px`;\n    }\n  }\n\n  /**\n   * Return either the `left` or `top` of the window's list element, depending on the direction of the window.\n   */\n  get pos(): number {\n    const property = this.horizontal ? \"left\" : \"top\";\n    return parseInt(getComputedStyle(this.listEl).getPropertyValue(property).replace(\"px\", \"\"));\n  }\n\n  private handlePointerOver = (e: PointerEvent): void => {\n    e.preventDefault();\n\n    if (!this.isHoverable) return;\n\n    const target = e.target as HTMLElement;\n    if (!target.classList.contains(\"proseplay-current\")) return;\n\n    (this.el.closest(\".proseplay\") as HTMLElement).querySelectorAll(\".proseplay-line\").forEach(line => {\n      line.classList.add(\"proseplay-has-hover\");\n    });\n    this.pointerOver();\n  }\n\n  pointerOver() {\n    this.el.classList.add(\"proseplay-hover\");\n  }\n\n  private handlePointerDown = (e: PointerEvent): void => {\n    e.preventDefault();\n\n    if (!this.isHoverable) return;\n\n    const target = e.target as HTMLElement;\n    if (!target.classList.contains(\"proseplay-current\")) return;\n\n    this.el.setPointerCapture(e.pointerId);\n\n    this.links.forEach(window => window.pointerDown());\n    this.isDragged = true;\n\n    mouse.x = e.clientX;\n    mouse.y = e.clientY;\n  }\n\n  pointerDown() {\n    this.el.classList.add(\"proseplay-hover\");\n  }\n\n  private handlePointerMove = (e: PointerEvent): void => {\n    e.preventDefault();\n\n    if (!this.isDragged) return;\n\n    const dist = !this.horizontal ? mouse.y - e.clientY : mouse.x - e.clientX;\n    this.slideToPos(this.pos - dist);\n    this.links.forEach(window => {\n      window.slideToPos(this.pos - dist);\n    });\n    mouse.x = e.clientX;\n    mouse.y = e.clientY;\n  }\n\n  private handlePointerOut = (): void => {\n    if (this.isDragged) return;\n    (this.el.closest(\".proseplay\") as HTMLElement).querySelectorAll(\".proseplay-line\").forEach(line => {\n      line.classList.remove(\"proseplay-has-hover\");\n    });\n    this.pointerOut();\n    this.links.forEach(window => window.pointerOut());\n  }\n  \n  pointerOut() {\n    this.isDragged = false;\n    this.el.classList.remove(\"proseplay-hover\");\n  }\n\n  private handlePointerUp = (e: PointerEvent): void => {\n    e.preventDefault();\n\n    this.pointerUp();\n    this.links.forEach(window => window.pointerUp());\n  }\n\n  pointerUp(): void {\n    this.snapToNearestChoice();\n    this.isDragged = false;\n    this.el.classList.remove(\"proseplay-hover\");\n\n    let functionName = this.functionNames[this.currentIndex];\n    if (functionName) {\n      if (this.functions[functionName]) {\n        this.functions[functionName]();\n      }\n    }\n\n    (this.el.closest(\".proseplay\") as HTMLElement).querySelectorAll(\".proseplay-line\").forEach(line => {\n      line.classList.remove(\"proseplay-has-hover\");\n    })\n  }\n\n  /**\n   * Set link between this window and other windows.\n   * @param linkIndex Index number of link, as indicated in square brackets.\n   * @param otherWindows Array of other windows in the same link.\n   */\n  setLink(linkIndex: number | null, otherWindows: Window[]): void {\n    this.linkIndex = linkIndex;\n    if (linkIndex) {\n      const sup = linkRefTemplate.cloneNode(true) as HTMLElement;\n      this.el.insertAdjacentElement(\"afterend\", sup);\n      sup.innerText = `${linkIndex}`;\n    }\n    this.links = otherWindows;\n  }\n\n  /**\n   * Set function names.\n   * @param functionNames Array of function names.\n   */\n  setFunctionNames(functionNames: string[]): void {\n    this.functionNames = functionNames;\n  }\n\n  /**\n   * Assign functions to function names.\n   * @param name Name of function.\n   * @param fnc Function to be called.\n   */\n  setFunction(name: string, fnc: Function): void {\n    this.functions[name] = fnc;\n  }\n}\n\nexport { Window }","const choiceTemplate = document.createElement(\"div\");\nchoiceTemplate.classList.add(\"proseplay-choice\");\n\nclass Choice {\n  el: HTMLElement;\n  text: string = \"\";\n  isCurrent: boolean = false;\n\n  constructor(text: string) {\n    this.text = text;\n\n    this.el = choiceTemplate.cloneNode(true) as HTMLElement;\n    if (text !== \" \") {\n      this.el.innerText = text;\n    } else {\n      this.el.innerHTML = \"&thinsp;\";\n    }\n  }\n\n  /**\n   * Activate this choice.\n   */\n  activate() {\n    this.isCurrent = true;\n    this.el.classList.add(\"proseplay-current\");\n  }\n  \n  /**\n   * Deactivate this choice.\n   */\n  deactivate() {\n    this.isCurrent = false;\n    this.el.classList.remove(\"proseplay-current\");\n  }\n\n  /**\n   * Get the `offsetTop` of this element.\n   */\n  get offsetTop(): number {\n    return this.el.offsetTop;\n  }\n\n  /**\n   * Get the `offsetLeft` of this element.\n   */\n  get offsetLeft(): number {\n    return this.el.offsetLeft;\n  }\n\n  /**\n   * Get the `offsetWidth` of this element.\n   */\n  get offsetWidth(): number {\n    return this.el.offsetWidth;\n  }\n}\n\nexport { Choice }"],"names":["$9b061c90e4c8fb40$var$$97aedba7ab332eed$var$PADDING","$9b061c90e4c8fb40$var$$79098f0a1478fa01$var$EM","$9b061c90e4c8fb40$var$$97aedba7ab332eed$var$windowTemplate","document","createElement","classList","add","$9b061c90e4c8fb40$var$$97aedba7ab332eed$var$listTemplate","append","$9b061c90e4c8fb40$var$$97aedba7ab332eed$var$linkRefTemplate","$9b061c90e4c8fb40$var$$97aedba7ab332eed$var$mouse","x","y","$9b061c90e4c8fb40$var$$97aedba7ab332eed$export$cec157cbbbaf65c9","links","horizontal","constructor","parent","el","cloneNode","appendChild","addEventListener","handlePointerOver","handlePointerDown","handlePointerMove","handlePointerUp","handlePointerOut","listEl","querySelector","choices","currentIndex","isHoverable","isDragged","linkIndex","functionNames","functions","parseInt","getComputedStyle","fontSize","setHorizontal","addChoice","choice","push","activateChoice","style","left","Math","abs","offsetLeft","top","offsetTop","indexOf","forEach","otherChoice","deactivate","activate","width","offsetWidth","random","floor","length","slideToPos","pos","targetChoice","getNearestChoice","slideToChoice","choiceIndex","duration","pointerOver","pointerDown","e","target","remove","transitionDuration","removeProperty","setTimeout","pointerUp","pointerOut","minDist","Infinity","dist","snapToNearestChoice","property","getPropertyValue","replace","preventDefault","contains","closest","querySelectorAll","line","setPointerCapture","pointerId","window1","clientX","clientY","functionName","setLink","otherWindows","sup","insertAdjacentElement","innerText","setFunctionNames","setFunction","name","fnc","$9b061c90e4c8fb40$var$$fb2114d596aef9c8$var$choiceTemplate","$9b061c90e4c8fb40$var$$fb2114d596aef9c8$export$32a7462f6a06cbd5","text","isCurrent","innerHTML","$9b061c90e4c8fb40$var$$79098f0a1478fa01$var$lineTemplate","$9b061c90e4c8fb40$var$$79098f0a1478fa01$var$samples","dickinson","homophones","hypothetically","$9b061c90e4c8fb40$export$bb601a587602e2b4","lines","windows","_isExpanded","window","handleResize","createInstance","container","body","load","parse","pp","str","textTokens","trim","split","lineTokens","m","matchAll","RegExp","currIndex","match","index","isEscaped","prevToken","strings","currentToken","slice","i","s","constructText","lineEl","tokens","token","span","filter","otherWindow","randomise","options","windowIndexes","map","_","windowsDragged","includes","millis","randomize","expand","toggle","em","parseFloat","marginBottom","height","scrollHeight","marginTop","max","maxWidth","opacity","collapse","isExpanded","snapshot","currentIndexes","slideWindow","windowIndex","$98d79d017ae06d24$var$poem","$98d79d017ae06d24$var$pp","event","curr"],"version":3,"file":"index.3ceab00c.js.map"}